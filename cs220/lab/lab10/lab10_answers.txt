CS-220 Spring 2017 Lab 10 answers		Due: April 25, 2017

1. Cut and paste a copy of your successful test.txt file that creates a texthex.txt 
   file that invokes the target function:
   
2. Notice that the target function in target.c ends with an "exit(0)" invocation.  The
   "exit(0)" causes the target function to return directly to the operating system cleanup
   routine instead of to the function that called "target".  If the target function had 
   ended with "return false" instead of "exit(0)", would target still run sucessfully?
   If not, what might happen and why?
   If the function returned false, then you would continue on into a different section of instructions, when you exit(0);, it tells the program to go back to the execution of the instructions prior to our overflow redirection. If we didn't go back to that next instruction, then we would never print out what we overloaded the buffer with. Therefore, you would continue to run through the target program and print out the other string "Yech.." instead of the intended string.
   
3. If target.c had used fgets instead of gets, would your buffer overflow attack have been succesful?
   Why or why not?
   fgets requires you to pass in the buffer size, so it will never overflow. Thus, the overflow attack won't work as the input string will not be taken if it is over the size. (Throws an exception? I'm not sure exactly what happens).
   
4. Did the Makefile make this lab easier or harder to run?  Is it worth the time to build a correct
   Makefile so that dependencies are automatically taken care of?
   The Makefile is definitely easier to use in this case, however if you are doing multiple different things (i.e. using different gcc suffixes or something) then it may be more useful to just type them in each time in stead of changing the make file every time you want to do something new.
   
5. Now that you know how to do a buffer overflow attack, could you do a buffer overflow
   attack on target WITHOUT looking at target.c?  If not, why not?  If so, what tools
   would you use to figure out what is in the "target" executable file?
   If you could look in gdb to find how far down the stack pointer moves when the buffer is instantiated, then you would know the size of the buffer. 